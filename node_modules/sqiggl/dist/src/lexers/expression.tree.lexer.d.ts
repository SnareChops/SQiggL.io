import { DSLExpressionTree } from '../dsl';
import { LexerOptions } from '../lexer';
import { Expression } from '../expressions';
import { Conjunction } from '../conjunctions';
/**
 * The lexer responsible for all expression tree DSL generation.
 *
 * @internal
 */
export declare class ExpressionTreeLexer {
    private options;
    private expressions;
    private conjunctions;
    /**
     * Creates a new instance of ExpressionTreeLexer
     *
     * @param options {LexerOptions} - The LexerOptions to use for DSL generation.
     * @param expressions {Expression[]} - List of known expressions to use for DSL generation.
     * @param conjunctions {Conjunction[]} - List of known conjunctions to use for DSL generation.
     */
    constructor(options: LexerOptions, expressions: Expression[], conjunctions: Conjunction[]);
    /**
     * Determine if any of the parts match a conjunction and split the parts into
     * separate parts arrays (removing the conjunction after identifying and adding to the DSL),
     * feeding the split parts into the {@link ExpressionLexer} and then appending the results
     * onto 'branches'.
     *
     * @param parts {string[]} - The parts to generate DSL for.
     * @returns {T} - The appropriate ExpressionTree that was requested.
     */
    invoke<T extends DSLExpressionTree>(parts: string[]): T;
}
