var expression_lexer_1 = require('./expression.lexer');
/**
 * The lexer responsible for all expression tree DSL generation.
 *
 * @internal
 */
var ExpressionTreeLexer = (function () {
    /**
     * Creates a new instance of ExpressionTreeLexer
     *
     * @param options {LexerOptions} - The LexerOptions to use for DSL generation.
     * @param expressions {Expression[]} - List of known expressions to use for DSL generation.
     * @param conjunctions {Conjunction[]} - List of known conjunctions to use for DSL generation.
     */
    function ExpressionTreeLexer(options, expressions, conjunctions) {
        this.options = options;
        this.expressions = expressions;
        this.conjunctions = conjunctions;
    }
    /**
     * Determine if any of the parts match a conjunction and split the parts into
     * separate parts arrays (removing the conjunction after identifying and adding to the DSL),
     * feeding the split parts into the {@link ExpressionLexer} and then appending the results
     * onto 'branches'.
     *
     * @param parts {string[]} - The parts to generate DSL for.
     * @returns {T} - The appropriate ExpressionTree that was requested.
     */
    ExpressionTreeLexer.prototype.invoke = function (parts) {
        var dsl = {}, idx = 0, singleExpressionParts;
        while (idx < parts.length) {
            for (var _i = 0, _a = this.conjunctions; _i < _a.length; _i++) {
                var con = _a[_i];
                for (var _b = 0, _c = con.keys; _b < _c.length; _b++) {
                    var key = _c[_b];
                    if (parts[idx] === key) {
                        if (!dsl.conjunctions)
                            dsl.conjunctions = [];
                        dsl.conjunctions.push(con);
                        singleExpressionParts = parts.splice(0, idx - 1);
                        parts.splice(0, 3);
                        if (!dsl.branches)
                            dsl.branches = [];
                        dsl.branches.push(new expression_lexer_1.ExpressionLexer(this.options, this.expressions).invoke(singleExpressionParts));
                        idx = 0;
                    }
                }
            }
            idx++;
        }
        if (!dsl.branches)
            dsl.branches = [];
        dsl.branches.push(new expression_lexer_1.ExpressionLexer(this.options, this.expressions).invoke(parts));
        return dsl;
    };
    return ExpressionTreeLexer;
})();
exports.ExpressionTreeLexer = ExpressionTreeLexer;
