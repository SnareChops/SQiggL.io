var lexer_1 = require('../lexer');
var dsl_1 = require('../dsl');
var error_1 = require("../error");
/**
 * The Lexer responsible for all DSL generation of variable statements
 *
 * @internal
 */
var VariableLexer = (function () {
    /**
     * Creates a new instance of the VariableLexer
     *
     * @internal
     * @param options {LexerOptions} - The LexerOptions to use when generating DSL
     */
    function VariableLexer(options) {
        this.options = options;
    }
    /**
     * Walk through a variable declaration and return a variable DSL
     *
     * TODO: Add rules
     *
     * @internal
     * @param input {string}
     * @returns {DSLVariable}
     */
    VariableLexer.prototype.invoke = function (input) {
        var currentType = dsl_1.DSLVariableType.key, original = input, idx = 0, startIdx = 0, inString = false, isArray = false, stringChar, dsl = { literal: input };
        while (idx < input.length) {
            switch (input.charAt(idx)) {
                case "'":
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2000', 'Variable keys should not be wrapped in quotes.');
                    if (!inString) {
                        inString = true;
                        stringChar = "'";
                        idx++;
                        break;
                    }
                    if (input[idx] === stringChar) {
                        if (input[idx - 1] === this.options.stringEscapeChar) {
                            input = input.slice(0, idx - 1) + input.slice(idx);
                            break;
                        }
                        else
                            inString = false;
                    }
                    idx++;
                    break;
                case '"':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2000', 'Variable keys should not be wrapped in quotes.');
                    if (!inString) {
                        inString = true;
                        stringChar = '"';
                        idx++;
                        break;
                    }
                    if (input[idx] === stringChar) {
                        if (input[idx - 1] === this.options.stringEscapeChar) {
                            input = input.slice(0, idx - 1) + input.slice(idx);
                            break;
                        }
                        else
                            inString = false;
                    }
                    idx++;
                    break;
                case '[':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2001', "Invalid character '[' found in variable key: '" + original + "'.");
                    if (!inString) {
                        if (idx !== startIdx)
                            throw error_1.SQiggLError('LV2002', "Arrays in variables cannot be nested. At '" + original + "'.");
                        input = input.slice(0, idx) + input.slice(idx + 1);
                        isArray = true;
                    }
                    break;
                case ']':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2001', "Invalid character ']' found in variable key: '" + original + "'.");
                    if (!inString) {
                        if (idx !== input.length - 1)
                            throw error_1.SQiggLError('LV2003', "Variables that define arrays must not include other values: '" + original + "'.");
                        input = input.slice(0, idx) + input.slice(idx + 1);
                    }
                    console.log(input);
                    idx++;
                    break;
                case this.options.variableAssignmentChar:
                    dsl = this.generateDSL(dsl, currentType, input.slice(startIdx, idx), isArray);
                    idx++;
                    startIdx = idx;
                    currentType = dsl_1.DSLVariableType.value;
                    break;
                default:
                    idx++;
            }
        }
        if (startIdx !== 0)
            dsl = this.generateDSL(dsl, currentType, input.slice(startIdx), isArray);
        return dsl;
    };
    /**
     * Generate the DSL for a variable piece by piece. Building on the definition until complete.
     *
     * @internal
     * @param dsl {DSLVariable}
     * @param type {DSLVariableType}
     * @param value {string}
     * @param isArray {boolean}
     * @returns {DSLVariable}
     */
    VariableLexer.prototype.generateDSL = function (dsl, type, value, isArray) {
        switch (type) {
            case dsl_1.DSLVariableType.key:
                dsl.key = value;
                break;
            case dsl_1.DSLVariableType.value:
                dsl.value = isArray ? this.convertCSVToArray(value) : value;
                break;
            /* istanbul ignore next */
            default:
                /* istanbul ignore next */
                throw error_1.SQiggLError('LV100', 'Unrecognized DSLVariableType');
        }
        return dsl;
    };
    VariableLexer.prototype.convertCSVToArray = function (input) {
        var items = input.split(','), result = [];
        for (var _i = 0; _i < items.length; _i++) {
            var item = items[_i];
            item = item.trim();
            result.push(lexer_1.Lexer.removeEscapeCharactersFromStringPart(item, this.options));
        }
        return result;
    };
    /**
     * Clean and prepare the input for parsing
     *
     * @internal
     * @param input {string}
     * @returns {string}
     */
    VariableLexer.cleanStringForLexing = function (input) {
        return input.replace('\n', ' ').replace(/ (?=(?:(?:\\.|"(?:\\.|[^"\\])*"|[^\\'"])*'(?:\\.|"(?:\\.|[^"'\\])*"|[^\\'])*')*(?:\\.|"(?:\\.|[^"\\])*"|[^\\'])*$)(?=(?:(?:\\.|'(?:\\.|[^'\\])*'|[^\\'"])*"(?:\\.|'(?:\\.|[^'"\\])*'|[^\\"])*")*(?:\\.|'(?:\\.|[^'\\])*'|[^\\"])*$)/g, '').trim();
    };
    return VariableLexer;
})();
exports.VariableLexer = VariableLexer;
