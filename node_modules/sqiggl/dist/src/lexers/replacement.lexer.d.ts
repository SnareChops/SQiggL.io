import { LexerOptions } from '../lexer';
import { DSLReplacement } from '../dsl';
import { Expression } from '../expressions';
import { Conjunction } from "../conjunctions";
/**
 * The lexer responsible for DSL generation of all Replacement statements
 *
 * @internal
 */
export declare class ReplacementLexer {
    private options;
    private expressions;
    private conjunctions;
    /**
     * Creates a new instance of the Replacement Lexer
     *
     * @internal
     * @param options {LexerOptions} - The LexerOptions to use for all DSL generation.
     * @param expressions {Expression[]} - A list of all known expressions to use when generating DSL.
     * @param conjunctions {Conjunction[]} - A list of all known conjunctions to use when generating DSL.
     */
    constructor(options: LexerOptions, expressions: Expression[], conjunctions: Conjunction[]);
    /**
     * Split the input into it's respective parts then compare them against expressions
     * or return the input if the contents are literal.
     *
     * TODO: Add Rules
     *
     * @internal
     * @param input {string}
     * @param parts {string[]} - The "Parts" of the input. {@see Lexer.extractParts} for more details on the definition of a "Part".
     * @returns {DSLReplacement}
     */
    invoke(input: string, parts: string[]): DSLReplacement;
    /**
     * Clean and prepare the input for parsing
     *
     * @internal
     * @param input {string}
     * @returns {string}
     */
    static cleanStringForLexing(input: string): string;
}
