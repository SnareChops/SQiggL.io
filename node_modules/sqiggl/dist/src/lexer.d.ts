import { DSL } from './dsl';
import { Action } from './actions';
import { Expression } from './expressions';
import { Conjunction } from './conjunctions';
import { Modifier } from './modifiers';
export interface LexerOptions {
    leftWrapperChar?: string;
    rightWrapperChar?: string;
    commandChar?: string;
    variableChar?: string;
    commentChar?: string;
    variableAssignmentChar?: string;
    stringEscapeChar?: string;
    customActions?: Action[];
    customExpressions?: Expression[];
    customModifiers?: Modifier[];
    customConjunctions?: Conjunction[];
    includeCoreLibrary?: boolean;
}
export declare const DEFAULT_LEXER_OPTIONS: LexerOptions;
/**
 * The parent lexer to all specific lexers.
 *
 * Performs all identification of statements and prepares all text for
 * parsing by the specific lexers.
 *
 * @internal
 */
export declare class Lexer {
    private options;
    /**
     * A list of all known Actions (including custom actions defined and imported by plugins)
     *
     * @internal
     */
    private actions;
    /**
     * A list of all known Expressions (including custom expressions defined and imported by plugins)
     *
     * @internal
     */
    private expressions;
    /**
     * A list of all known Modifiers (including custom modifiers defined and imported by plugins)
     *
     * @internal
     */
    private modifiers;
    /**
     * A list of all known Conjunctions (including custom conjunctions defined and imported by plugins)
     *
     * @internal
     */
    private conjunctions;
    /**
     * Creates a new instance of Lexer
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation
     */
    constructor(options?: LexerOptions);
    /**
     * Set the lexer options to either the provided options, or the defaults
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generations
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    private setOptions(options);
    /**
     * Validate that the options will not conflict with each other.
     * *All* provided string character options *must* be unique
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    private validateOptions(options);
    /**
     * Add the core Actions, Expressions, and Modifiers.
     * These will not be set if `options.includeCoreLibrary` is false.
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    private setLibTypes(options);
    /**
     * Add any custom Actions, Expressions, or Modifiers provided.
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    private setCustomTypes(options);
    /**
     * Beginning the parsing process, this method will guide the inputted string
     * through the parsing process and output the full DSL used to then execute
     * by the "Parser"
     *
     * @internal
     * @param input {string} - The string to generate DSL for.
     * @returns {DSL[]} - The final DSL to be passed to the Parser.
     */
    parse(input: string): DSL[];
    /**
     * Identify all special parts found in the SQiggL query. This then routes the found
     * identified statements to the individual DSL parsers to create the appropriate DSL
     * for the query.
     *
     * @internal
     * @param input {string} - The string to identify different statements and generate DSL for.
     * @returns {DSL[]} - The now identified and fully parsed DSL, ready for leveling and scoping.
     */
    private identify(input);
    /**
     * Choose the correct DSL representation for the found type and parse/generate it
     *
     * @internal
     * @param type {DSLType}
     * @param value {string}
     * @returns {DSL}
     */
    private generateDSL(type, value);
    /**
     * Assigns levels to the current DSL
     *
     * Rules:
     *  - If an action is found check if it's a DependentAction
     *      - If the action is not a dependent, save on current level and increase the level for the next items
     *      - If the action is a dependent, move up a level and save the item
     *      - If the action is not a TerminatingAction, move the level back down for more nested items
     *  - If no action is found, save the item on the current level
     *
     * @internal
     * @param dsls {DSL[]} - The current DSL array
     * @returns {LeveledDSL[]}
     */
    private levelDSL(dsls);
    /**
     * Uses the previously defined levels to correctly nest the DSL into scopes
     *
     * *uses a top-down approach*
     *
     * Rules: (`down === level++`) *down means the level has increased*
     *  - If the item is at the same level, move to the next item in the array
     *  - If the item is down a level, cut/paste all direct siblings at or below
     *    the current level onto the previous item and then recursively scope those
     *
     * @internal
     * @param leveledDSL - The leveled DSL returned from levelDSL
     * @returns {DSL[]}
     */
    private scopeDSL(leveledDSL);
    /**
     * Split the found string into parts
     * A part is any set of characters, separated by a space.
     * Words within a literal string are *not* split. They are treated as one "Part".
     *
     * @internal
     * @param input {string}
     * @returns {string[]}
     */
    private extractParts(input);
    /**
     * Finds a single "part".
     * If the "part" is a literal string, use the `extractString` method instead.
     *
     * @internal
     * @param input {string}
     * @param start {number} - The starting index to search
     * @returns {string}
     */
    private extractWord(input, start);
    /**
     * Finds a single "part" that is a literal string.
     * Honors escaped quotes.
     *
     * @internal
     * @param input {string}
     * @param start {number} - The starting index to search
     * @param stringChar {string} - Which type of quote was used
     * @returns {string}
     */
    private extractString(input, start, stringChar);
    /**
     * Removes the escape characters from strings leaving the raw string itself
     *
     * This method is the iterator for `Lexer.removeEscapeCharactersFromStringPart`
     * which performs the actual removal.
     *
     * @internal
     * @param parts {string[]} - The parts to check for strings and remove the escapes from.
     * @param options {LexerOptions} - The LexerOptions to use for this operation.
     * @returns {string[]}
     */
    static removeEscapeCharactersFromStringParts(parts: string[], options: LexerOptions): string[];
    /**
     * Removes the escape characters from a string leaving the raw string itself
     *
     * This method **only** removes the escape characters that actually perform an escape,
     * escaped escape characters are left intact.
     *
     * @internal
     * @param part {string} - The part to check if is a string and remove escape characters from.
     * @param options {LexerOptions} - The LexerOptions to use for this operation.
     * @returns {string}
     */
    static removeEscapeCharactersFromStringPart(part: string, options: LexerOptions): string;
}
