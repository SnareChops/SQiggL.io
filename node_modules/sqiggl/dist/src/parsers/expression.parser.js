var parser_1 = require('../parser');
/**
 * The parser responsible for parsing all DSLExpressions.
 *
 * @internal
 */
var ExpressionParser = (function () {
    /**
     * Creates a new instance of ExpressionParser.
     *
     * @internal
     * @param options {ParserOptions} - The {@link ParserOptions} for string output.
     */
    function ExpressionParser(options) {
        this.options = options;
    }
    /**
     * Take a DSLExpression and output the final string or boolean.
     *
     * @internal
     * @param dsl {DSLExpression} - The DSL to parse.
     * @param variables {ScopedVariables} - The list of known variables for this scope.
     * @returns {ExpressionResult} - The result of the expression.
     */
    ExpressionParser.prototype.parse = function (dsl, variables) {
        var idx, result = { value: null };
        for (idx = 0; idx < dsl.values.length; idx++) {
            dsl.values[idx] = parser_1.Parser.resolveValue(dsl.values[idx], variables, !!dsl.expression.suppressUndefinedVariableError);
        }
        result.value = dsl.expression.rule(dsl.values, dsl.literal);
        if (!!dsl.modifiers) {
            for (var _i = 0, _a = dsl.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                // Should remove this <any> cast once possible. This is an ugly hack and should be corrected.
                result.value = modifier.rule(result.value, dsl.values);
            }
        }
        if (!!dsl.joiner && dsl.local) {
            result.iterable = {
                joiner: dsl.joiner,
                local: dsl.local
            };
        }
        return result;
    };
    return ExpressionParser;
})();
exports.ExpressionParser = ExpressionParser;
