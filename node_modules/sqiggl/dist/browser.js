(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var sqiggl_1 = require("./src/sqiggl");
/* istanbul ignore next */
if (typeof window !== 'undefined') {
    /* istanbul ignore next */
    window['SQiggL'] = sqiggl_1.SQiggL;
}
module.exports = sqiggl_1.SQiggL;

},{"./src/sqiggl":20}],2:[function(require,module,exports){
var parser_1 = require('./parser');
/**
 * @internal
 */
exports.If = {
    key: 'if',
    rule: function (expressionResult, variables, scope, parser) { return expressionResult.value ? parser.parse(scope, variables) : null; }
};
/**
 * @internal
 */
exports.EndIf = {
    key: 'endif',
    dependents: [exports.If],
};
/**
 * @internal
 */
exports.Unless = {
    key: 'unless',
    rule: function (expressionResult, variables, scope, parser) { return !expressionResult.value ? parser.parse(scope, variables) : null; }
};
/**
 * @internal
 */
exports.EndUnless = {
    key: 'endunless',
    dependents: [exports.Unless],
};
/**
 * @internal
 */
exports.Else = {
    key: 'else',
    dependents: [exports.If, exports.Unless],
    rule: function (expressionResult, variables, scope, parser) { return parser.parse(scope, variables); }
};
/**
 * @internal
 */
exports.For = {
    key: 'for',
    rule: function (expressionResult, variables, scope, parser) {
        if (variables === void 0) { variables = {}; }
        var output = [];
        for (var _i = 0, _a = expressionResult.value; _i < _a.length; _i++) {
            var value = _a[_i];
            variables[expressionResult.iterable.local] = value;
            output.push(parser.parse(scope, variables));
        }
        return output.join(parser_1.Parser.resolveValue(expressionResult.iterable.joiner, variables) + " ");
    }
};
/**
 * @internal
 */
exports.EndFor = {
    key: 'endfor',
    dependents: [exports.For]
};
/**
 * @internal
 */
exports.End = {
    key: 'end',
    dependents: [exports.If, exports.Unless, exports.For]
};
exports.CORE_ACTIONS = [
    exports.If,
    exports.Else,
    exports.EndIf,
    exports.Unless,
    exports.EndUnless,
    exports.For,
    exports.EndFor,
    exports.End
];

},{"./parser":14}],3:[function(require,module,exports){
/**
 * @internal
 */
exports.AndConjunction = {
    keys: ['and', '&&'],
    rule: function (expressionResults) { return expressionResults[0] && expressionResults[1]; }
};
/**
 * @internal
 */
exports.OrConjunction = {
    keys: ['or', '||'],
    rule: function (expressionResults) { return expressionResults[0] || expressionResults[1]; }
};
exports.CORE_CONJUNCTIONS = [
    exports.AndConjunction,
    exports.OrConjunction
];

},{}],4:[function(require,module,exports){
/**
 * @internal
 */
(function (DSLType) {
    DSLType[DSLType["text"] = 0] = "text";
    DSLType[DSLType["variable"] = 1] = "variable";
    DSLType[DSLType["replacement"] = 2] = "replacement";
    DSLType[DSLType["command"] = 3] = "command";
    DSLType[DSLType["comment"] = 4] = "comment";
})(exports.DSLType || (exports.DSLType = {}));
var DSLType = exports.DSLType;
/**
 * @internal
 */
(function (DSLVariableType) {
    DSLVariableType[DSLVariableType["key"] = 0] = "key";
    DSLVariableType[DSLVariableType["value"] = 1] = "value";
})(exports.DSLVariableType || (exports.DSLVariableType = {}));
var DSLVariableType = exports.DSLVariableType;

},{}],5:[function(require,module,exports){
/**
 * Creates a new SQiggL Error
 *
 * @internal
 * @param code {string} - The code of the error.
 * @param message {string} - The message of the error.
 * @returns {Error} - A Javascript error object.
 */
function SQiggLError(code, message) {
    return new Error("SQiggLError - " + code + ": " + message);
}
exports.SQiggLError = SQiggLError;

},{}],6:[function(require,module,exports){
var modifiers_1 = require('./modifiers');
exports.VALUE = '(v)';
exports.LOCALVARIABLE = '(l)';
exports.JOINER = '(j)';
exports.SPACE = ' ';
/**
 * @internal
 */
exports.Equal = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], '=', [{ 0: modifiers_1.OrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return values[0] == values[1]; }
};
/**
 * @internal
 */
exports.GreaterThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], '>', [{ 0: modifiers_1.OrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return (+values[0]) > (+values[1]); }
};
/**
 * @internal
 */
exports.LessThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], '<', [{ 0: modifiers_1.OrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return (+values[0]) < (+values[1]); }
};
/**
 * @internal
 */
exports.IsNull = {
    template: [exports.VALUE, exports.SPACE, 'is', exports.SPACE, [{ 0: modifiers_1.Not }], 'null'],
    rule: function (values) { return values[0] == null; },
    suppressUndefinedVariableError: true
};
/**
 * @internal
 */
exports.LexicalGreaterThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], 'abc>', [{ 0: modifiers_1.OrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return [values[0], values[1]].sort().indexOf(values[0]) > 0; }
};
/**
 * @internal
 */
exports.LexicalLessThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], 'abc<', [{ 0: modifiers_1.OrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return values[0] === values[1] ? false : [values[0], values[1]].sort().indexOf(values[0]) === 0; }
};
/**
 * @internal
 */
exports.LengthGreaterThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], 'len>', [{ 0: modifiers_1.LengthOrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return values[0].length > +values[1]; }
};
/**
 * @internal
 */
exports.LengthLessThan = {
    template: [exports.VALUE, exports.SPACE, [{ 1: modifiers_1.Not }], 'len<', [{ 0: modifiers_1.LengthOrEqual }], exports.SPACE, exports.VALUE],
    rule: function (values) { return values[0].length < +values[1]; }
};
/**
 * @internal
 */
exports.IsNaN = {
    template: [exports.VALUE, exports.SPACE, 'is', exports.SPACE, [{ 0: modifiers_1.Not }], 'NaN'],
    rule: function (values) { return isNaN(Number(values[0])); }
};
/**
 * @internal
 */
exports.Between = {
    template: [exports.VALUE, exports.SPACE, exports.VALUE, exports.SPACE, '>', [{ 1: modifiers_1.Not }], [{ 0: modifiers_1.BetweenOrEqual }], '<', exports.SPACE, exports.VALUE],
    rule: function (values) { return values[1] < values[0] && values[2] > values[0]; }
};
/**
 * @internal
 */
exports.Coalesce = {
    template: [exports.VALUE, exports.SPACE, '??', exports.SPACE, exports.VALUE],
    rule: function (values) { return (values[0] || values[1]).toString(); },
    suppressUndefinedVariableError: true
};
/**
 * @internal
 */
exports.IterableOfUsing = {
    template: [exports.LOCALVARIABLE, exports.SPACE, 'of', exports.SPACE, exports.VALUE, exports.SPACE, 'using', exports.SPACE, exports.JOINER],
    rule: function (values) { return values[0]; }
};
exports.CORE_EXPRESSIONS = [
    exports.Equal,
    exports.GreaterThan,
    exports.LessThan,
    exports.IsNull,
    exports.LexicalGreaterThan,
    exports.LexicalLessThan,
    exports.LengthGreaterThan,
    exports.LengthLessThan,
    exports.IsNaN,
    exports.Between,
    exports.Coalesce,
    exports.IterableOfUsing
];

},{"./modifiers":13}],7:[function(require,module,exports){
var dsl_1 = require('./dsl');
var actions_1 = require('./actions');
var expressions_1 = require('./expressions');
var conjunctions_1 = require('./conjunctions');
var modifiers_1 = require('./modifiers');
var variable_lexer_1 = require('./lexers/variable.lexer');
var replacement_lexer_1 = require('./lexers/replacement.lexer');
var command_lexer_1 = require('./lexers/command.lexer');
var error_1 = require('./error');
exports.DEFAULT_LEXER_OPTIONS = {
    leftWrapperChar: '{',
    rightWrapperChar: '}',
    commandChar: '%',
    variableChar: '+',
    commentChar: '#',
    variableAssignmentChar: ':',
    stringEscapeChar: '\\',
    includeCoreLibrary: true
};
/**
 * The parent lexer to all specific lexers.
 *
 * Performs all identification of statements and prepares all text for
 * parsing by the specific lexers.
 *
 * @internal
 */
var Lexer = (function () {
    /**
     * Creates a new instance of Lexer
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation
     */
    function Lexer(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.setOptions(this.options)
            .validateOptions(this.options)
            .setLibTypes(this.options)
            .setCustomTypes(this.options);
    }
    /**
     * Set the lexer options to either the provided options, or the defaults
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generations
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    Lexer.prototype.setOptions = function (options) {
        for (var _i = 0, _a = Object.keys(exports.DEFAULT_LEXER_OPTIONS); _i < _a.length; _i++) {
            var key = _a[_i];
            this.options[key] = options[key] || exports.DEFAULT_LEXER_OPTIONS[key];
        }
        return this;
    };
    /**
     * Validate that the options will not conflict with each other.
     * *All* provided string character options *must* be unique
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    Lexer.prototype.validateOptions = function (options) {
        var array = [];
        for (var _i = 0, _a = Object.keys(exports.DEFAULT_LEXER_OPTIONS); _i < _a.length; _i++) {
            var key = _a[_i];
            if (typeof options[key] === 'string')
                array.push(options[key]);
        }
        for (var i = 0; i < array.length - 1; i++) {
            if (array[i] === array[i + 1])
                throw error_1.SQiggLError('L1000', 'All LexerOption chars must be unique');
        }
        return this;
    };
    /**
     * Add the core Actions, Expressions, and Modifiers.
     * These will not be set if `options.includeCoreLibrary` is false.
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    Lexer.prototype.setLibTypes = function (options) {
        if (!!options.includeCoreLibrary) {
            this.actions = actions_1.CORE_ACTIONS;
            this.expressions = expressions_1.CORE_EXPRESSIONS;
            this.modifiers = modifiers_1.CORE_MODIFIERS;
            this.conjunctions = conjunctions_1.CORE_CONJUNCTIONS;
        }
        return this;
    };
    /**
     * Add any custom Actions, Expressions, or Modifiers provided.
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @returns {Lexer} - The Lexer (For convenience chaining of startup methods)
     */
    Lexer.prototype.setCustomTypes = function (options) {
        if (!!options.customActions)
            this.actions = this.actions.concat(options.customActions);
        if (!!options.customExpressions)
            this.expressions = this.expressions.concat(options.customExpressions);
        if (!!options.customModifiers)
            this.modifiers = this.modifiers.concat(options.customModifiers);
        if (!!options.customConjunctions)
            this.conjunctions = this.conjunctions.concat(options.customConjunctions);
        return this;
    };
    /**
     * Beginning the parsing process, this method will guide the inputted string
     * through the parsing process and output the full DSL used to then execute
     * by the "Parser"
     *
     * @internal
     * @param input {string} - The string to generate DSL for.
     * @returns {DSL[]} - The final DSL to be passed to the Parser.
     */
    Lexer.prototype.parse = function (input) {
        var dsl = this.identify(input);
        var leveledDSL = this.levelDSL(dsl);
        dsl = this.scopeDSL(leveledDSL);
        return dsl;
    };
    /**
     * Identify all special parts found in the SQiggL query. This then routes the found
     * identified statements to the individual DSL parsers to create the appropriate DSL
     * for the query.
     *
     * @internal
     * @param input {string} - The string to identify different statements and generate DSL for.
     * @returns {DSL[]} - The now identified and fully parsed DSL, ready for leveling and scoping.
     */
    Lexer.prototype.identify = function (input) {
        var currentType = dsl_1.DSLType.text, idx = 0, startIdx = 0, dsl = [];
        while (idx < input.length) {
            switch (input.charAt(idx)) {
                case this.options.leftWrapperChar:
                    if (currentType !== dsl_1.DSLType.text)
                        throw error_1.SQiggLError('L1001', "Unexpected '" + this.options.leftWrapperChar + "' found in statement. Expected '" + this.options.rightWrapperChar + "'.");
                    if (idx !== 0)
                        dsl.push(this.generateDSL(currentType, input.slice(startIdx, idx)));
                    switch (input.charAt(idx + 1)) {
                        case this.options.commandChar:
                            idx += 2;
                            currentType = dsl_1.DSLType.command;
                            break;
                        case this.options.commentChar:
                            idx += 2;
                            currentType = dsl_1.DSLType.comment;
                            break;
                        case this.options.variableChar:
                            idx += 2;
                            currentType = dsl_1.DSLType.variable;
                            break;
                        default:
                            idx++;
                            currentType = dsl_1.DSLType.replacement;
                    }
                    startIdx = idx; // Set start index for next type
                    break;
                case this.options.rightWrapperChar:
                    if (idx !== 0)
                        dsl.push(this.generateDSL(currentType, input.slice(startIdx, idx))); // Append current type
                    idx++;
                    startIdx = idx;
                    currentType = dsl_1.DSLType.text;
                    break;
                default:
                    idx++;
            }
        }
        if (currentType !== dsl_1.DSLType.text)
            throw error_1.SQiggLError('L1002', "Expected statement to complete before end of file.");
        if (startIdx !== idx)
            dsl.push(this.generateDSL(currentType, input.slice(startIdx)));
        return dsl;
    };
    /**
     * Choose the correct DSL representation for the found type and parse/generate it
     *
     * @internal
     * @param type {DSLType}
     * @param value {string}
     * @returns {DSL}
     */
    Lexer.prototype.generateDSL = function (type, value) {
        switch (type) {
            case dsl_1.DSLType.text:
                return { text: value };
            case dsl_1.DSLType.variable:
                value = variable_lexer_1.VariableLexer.cleanStringForLexing(value);
                return { variable: new variable_lexer_1.VariableLexer(this.options).invoke(value) };
            case dsl_1.DSLType.replacement:
                value = replacement_lexer_1.ReplacementLexer.cleanStringForLexing(value);
                return { replacement: new replacement_lexer_1.ReplacementLexer(this.options, this.expressions, this.conjunctions).invoke(value, this.extractParts(value)) };
            case dsl_1.DSLType.command:
                value = command_lexer_1.CommandLexer.cleanStringForLexing(value);
                return { command: new command_lexer_1.CommandLexer(this.options, this.actions, this.expressions, this.conjunctions).invoke(value, this.extractParts(value)) };
            case dsl_1.DSLType.comment:
                return { comment: value.trim() };
            /* istabnul ignore next */
            default:
                /* istanbul ignore next */
                throw error_1.SQiggLError('L100', 'Unrecognized DSLType');
        }
    };
    /**
     * Assigns levels to the current DSL
     *
     * Rules:
     *  - If an action is found check if it's a DependentAction
     *      - If the action is not a dependent, save on current level and increase the level for the next items
     *      - If the action is a dependent, move up a level and save the item
     *      - If the action is not a TerminatingAction, move the level back down for more nested items
     *  - If no action is found, save the item on the current level
     *
     * @internal
     * @param dsls {DSL[]} - The current DSL array
     * @returns {LeveledDSL[]}
     */
    Lexer.prototype.levelDSL = function (dsls) {
        var currentLevel = 0, levels = [], dsl;
        for (var _i = 0; _i < dsls.length; _i++) {
            dsl = dsls[_i];
            if (dsl.command && dsl.command.action) {
                if (dsl.command.action.dependents != null) {
                    levels.push({ level: --currentLevel, dsl: dsl });
                    if (currentLevel < 0)
                        throw error_1.SQiggLError('L1003', 'Your SQiggL is incorrectly nested.');
                    if (!!dsl.command.action.rule)
                        currentLevel++;
                }
                else {
                    levels.push({ level: currentLevel++, dsl: dsl });
                }
            }
            else {
                levels.push({ level: currentLevel, dsl: dsl });
            }
        }
        if (currentLevel > 0)
            throw error_1.SQiggLError('L1004', 'Your SQiggL query is nested but does not return to the top level before completing. Please check your nesting.');
        return levels;
    };
    /**
     * Uses the previously defined levels to correctly nest the DSL into scopes
     *
     * *uses a top-down approach*
     *
     * Rules: (`down === level++`) *down means the level has increased*
     *  - If the item is at the same level, move to the next item in the array
     *  - If the item is down a level, cut/paste all direct siblings at or below
     *    the current level onto the previous item and then recursively scope those
     *
     * @internal
     * @param leveledDSL - The leveled DSL returned from levelDSL
     * @returns {DSL[]}
     */
    Lexer.prototype.scopeDSL = function (leveledDSL) {
        var currentLevel = leveledDSL[0].level;
        var idx = 0;
        while (idx < leveledDSL.length) {
            if (leveledDSL[idx].level !== currentLevel) {
                var numberOfItems = leveledDSL.map(function (x) { return x.level; }).indexOf(currentLevel, idx) - idx;
                leveledDSL[idx - 1].dsl.scope = this.scopeDSL(leveledDSL.splice(idx, numberOfItems));
            }
            idx++;
        }
        return leveledDSL.map(function (x) { return x.dsl; });
    };
    /**
     * Split the found string into parts
     * A part is any set of characters, separated by a space.
     * Words within a literal string are *not* split. They are treated as one "Part".
     *
     * @internal
     * @param input {string}
     * @returns {string[]}
     */
    Lexer.prototype.extractParts = function (input) {
        var idx = 0, parts = [];
        var oops = 0;
        while (idx < input.length) {
            parts.push(this.extractWord(input, idx));
            idx += parts[parts.length - 1].length;
            if (input[idx] === ' ') {
                parts.push(expressions_1.SPACE);
                idx++;
            }
        }
        parts = Lexer.removeEscapeCharactersFromStringParts(parts, this.options);
        return parts;
    };
    /**
     * Finds a single "part".
     * If the "part" is a literal string, use the `extractString` method instead.
     *
     * @internal
     * @param input {string}
     * @param start {number} - The starting index to search
     * @returns {string}
     */
    Lexer.prototype.extractWord = function (input, start) {
        var nextSpace;
        if (input[start] === "'" || input[start] === '"') {
            return this.extractString(input, start, input[start]);
        }
        else {
            nextSpace = input.indexOf(' ', start);
            return input.slice(start, nextSpace > 0 ? nextSpace : input.length);
        }
    };
    /**
     * Finds a single "part" that is a literal string.
     * Honors escaped quotes.
     *
     * @internal
     * @param input {string}
     * @param start {number} - The starting index to search
     * @param stringChar {string} - Which type of quote was used
     * @returns {string}
     */
    Lexer.prototype.extractString = function (input, start, stringChar) {
        var idx = start + 1;
        while (idx < input.length) {
            switch (input[idx]) {
                case this.options.stringEscapeChar:
                    if (input[idx + 1] === this.options.stringEscapeChar || input[idx + 1] === stringChar) {
                        idx += 2;
                    }
                    else {
                        throw error_1.SQiggLError('L1005', "Illegal escape character found in string " + input + " at index " + idx);
                    }
                    break;
                case stringChar:
                    return input.slice(start, idx + 1);
                default:
                    idx++;
            }
        }
        throw error_1.SQiggLError('L1006', "Invalid string found in " + input);
    };
    /**
     * Removes the escape characters from strings leaving the raw string itself
     *
     * This method is the iterator for `Lexer.removeEscapeCharactersFromStringPart`
     * which performs the actual removal.
     *
     * @internal
     * @param parts {string[]} - The parts to check for strings and remove the escapes from.
     * @param options {LexerOptions} - The LexerOptions to use for this operation.
     * @returns {string[]}
     */
    Lexer.removeEscapeCharactersFromStringParts = function (parts, options) {
        for (var idx = 0; idx < parts.length; idx++) {
            parts[idx] = Lexer.removeEscapeCharactersFromStringPart(parts[idx], options);
        }
        return parts;
    };
    /**
     * Removes the escape characters from a string leaving the raw string itself
     *
     * This method **only** removes the escape characters that actually perform an escape,
     * escaped escape characters are left intact.
     *
     * @internal
     * @param part {string} - The part to check if is a string and remove escape characters from.
     * @param options {LexerOptions} - The LexerOptions to use for this operation.
     * @returns {string}
     */
    Lexer.removeEscapeCharactersFromStringPart = function (part, options) {
        if (part[0] === "'" || part[0] === '"') {
            part = part.replace(options.stringEscapeChar + "\"", '"')
                .replace(options.stringEscapeChar + "'", "'")
                .replace("" + options.stringEscapeChar + options.stringEscapeChar, "" + options.stringEscapeChar);
        }
        return part;
    };
    return Lexer;
})();
exports.Lexer = Lexer;

},{"./actions":2,"./conjunctions":3,"./dsl":4,"./error":5,"./expressions":6,"./lexers/command.lexer":8,"./lexers/replacement.lexer":11,"./lexers/variable.lexer":12,"./modifiers":13}],8:[function(require,module,exports){
var expression_tree_lexer_1 = require("./expression.tree.lexer");
var error_1 = require('../error');
/**
 * The lexer responsible for all DSL generation of Command statements
 *
 * @internal
 */
var CommandLexer = (function () {
    /**
     * Creates a new instance of CommandLexer
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} used for DSL generation.
     * @param actions {Action[]} - List of all known actions for DSL generation.
     * @param expressions {Expression[]} - List of all known expressions for DSL generation.
     * @param conjunctions {Conjunction[]} - List of all known conjunctions for DSL generation.
     */
    function CommandLexer(options, actions, expressions, conjunctions) {
        this.options = options;
        this.actions = actions;
        this.expressions = expressions;
        this.conjunctions = conjunctions;
    }
    /**
     * Search for a matching action in the command and return a DSLCommand
     *
     * As a rule all commands must start with an {@link Action} as the first "Part".
     * If an {@link Action} is not found, throw a No Action error
     *
     * - If the action has more that one "Part" then it must have an expression.
     *   Splice off the first two parts from the command, then check if it has more
     *   than one "Part".
     *   - If more than one "Part" then pass the reduced "Parts" to the {@link ExpressionLexer}
     *     and set the DSL equal to the now appended DSL with expression.
     *   - If only one "Part" then set the "Part" as the only value and expression to null.
     *     This is considered a variable and will be attempted to be resolved in the parser
     *     later.
     *
     * @internal
     * @param input {string}
     * @param parts {string[]} - The "Parts" of the input. {@see Lexer.extractParts} for more details on the definition of a "Part".
     * @returns {DSLCommand}
     */
    CommandLexer.prototype.invoke = function (input, parts) {
        var potential = this.actions.map(function (x) { return x.key.toLowerCase(); }).indexOf(parts[0].toLowerCase());
        if (potential < 0)
            throw error_1.SQiggLError('LC1000', "Commands require the first word to be a known action. " + parts[0] + " is not a recognized action.");
        var dsl = this.generateCommandDSL(this.actions[potential], input);
        if (parts.length > 1) {
            parts.splice(0, 2);
            if (parts.length > 1) {
                dsl.expressions = new expression_tree_lexer_1.ExpressionTreeLexer(this.options, this.expressions, this.conjunctions).invoke(parts);
            }
            else {
                dsl.expressions = null;
                dsl.literalValue = parts[0];
            }
        }
        return dsl;
    };
    /**
     * Create a DSL command from the matching Action definition
     *
     * @internal
     * @param definition {Action}
     * @param value {string}
     * @returns {DSLCommand}
     */
    CommandLexer.prototype.generateCommandDSL = function (definition, value) {
        return { literal: value, action: definition };
    };
    /**
     * Clean and prepare the input for parsing
     *
     * @internal
     * @param input {string}
     * @returns {string}
     */
    CommandLexer.cleanStringForLexing = function (input) {
        return input.replace(/\s+/g, ' ').trim();
    };
    return CommandLexer;
})();
exports.CommandLexer = CommandLexer;

},{"../error":5,"./expression.tree.lexer":10}],9:[function(require,module,exports){
var expressions_1 = require('../expressions');
var error_1 = require("../error");
/**
 * The lexer responsible for all Expression DSL generation.
 *
 * @internal
 */
var ExpressionLexer = (function () {
    /**
     * Creates a new instance of ExpressionLexer
     *
     * @internal
     * @param options {LexerOptions} - The {@link LexerOptions} for DSL generation.
     * @param expressions {Expression[]} - The list of known expressions for DSL generation.
     */
    function ExpressionLexer(options, expressions) {
        this.options = options;
        this.expressions = expressions;
    }
    /**
     * Walks the "Parts" of an expression comparing against known Expression templates
     * and rules them out one-by-one until a match is found.
     * **WARNING!** This method is **very** fragile.
     *
     * Rules: *rules are documented here and then referenced in the below method.*
     *
     * - Rule L1: If the template declares a local variable, save the variable and continue
     *   matching. if the match succeeds then set the local variable on the DSL.
     *
     * - Rule L2: Local variables once found and saved should be spliced from the clone.
     *   This prevents them from being confused with values in the outputted DSL.
     *
     * - Rule J1: If the template declares a joiner, save the joiner and continue matching.
     *   If the match succeeds then set the joiner on the DSL.
     *
     * - Rule J2: Once found and saved Joiners should be spliced from the clone.
     *   This prevents them from being confused with values in the outputted DSL.
     *
     * - Rule V1: If the template declares a VALUE then advance the indexes to the next parts.
     *   Values can't be matched against the template since they are user defined.
     *
     * - Rule S1: If the template declares a SPACE then compare the current item in the clone
     *   with the SPACE. If they are not equal then NO MATCH. Set isMatch to false and break the
     *   loop to try the next expression.
     *
     * - Rule S2: Successful SPACE matches should remove the SPACE from the clone to prevent
     *   it from being confused with the values in the outputted DSL.
     *
     * - Rule M1: Modifiers in expressions are optional, when searching for a modifier, if one is not found
     *   then move to the next part of the template and compare the same "Part" against that.
     *
     * - Rule M2: Modifiers that are directly before operators *may* have an optional space. If a space is found
     *   in the "Part" then splice out the space and compare the next "Part" against the operator.
     *
     * - Rule M3: Due to rule M2, if a Modifier is found check the length of the Modifier
     *   against the length of the "Part". Splice out the "Part" completely if the lengths
     *   are equal, else remove only the characters that represent the Modifier directly
     *
     * - Rule M4: NO LONGER A RULE!! If an operator has already been found in the template and a modifier was not
     *   matched then move to the next "Part" of the clone. This is a side effect of rule M3
     *
     * - Rule M5: If a modifier is successfully matched then inject it into the clone for
     *   eventual output in the DSL.
     *
     * - Rule O1: If an operator is declared in the template compare the "Part" against the
     *   operator. match only the same amount of characters as a modifier may follow the
     *   operator in the same "Part".
     *
     * - Rule O2: If rule O1 fails then NO MATCH. Set isMatch to false and break the loop and
     *   try the next expression.
     *
     * - Rule O3: If the operator and the "Part" are not the same length then splice out the
     *   operator from the "Part" leaving what remains. This is because a modifier may occupy
     *   the same "Part" and that should be matched in the next cycle.
     *
     * - Rule O4: NO LONGER A RULE!! If after applying Rule O3 the remaining "Part" is an empty string then
     *   splice out the "Part" from the clone.
     *
     * - Rule O5: If rule O3 doesn't apply, remove the "Part" from the clone. This prevents
     *   it from being confused with the values in the output DSL.
     *
     * - If no matching expression is found then throw an error.
     *
     * @internal
     * @param dsl {DSLExpression} - The DSL to which to append the found DSLExpression
     * @param parts {string} - The expression "Parts" as found in the replacement or command
     * @returns {DSLExpression} - The appended DSLExpression with all found expression properties.
     */
    ExpressionLexer.prototype.invoke = function (parts) {
        var dsl = { literal: this.craftLiteralFromParts(parts), expression: null }, expression, pidx, eidx, foundOrderedMod, foundIdentifier, clone, isMatch, operatorResolved, localVariable, joiner;
        for (var _i = 0, _a = this.expressions; _i < _a.length; _i++) {
            expression = _a[_i];
            // Set initial state for matching
            pidx = 0;
            eidx = 0;
            isMatch = true; // Assume is a match until found otherwise
            operatorResolved = false;
            clone = parts.slice(0); // Clone the array to protect original from modifications
            localVariable = null;
            joiner = null;
            while (eidx < expression.template.length) {
                var ePart = expression.template[eidx];
                if (ePart === expressions_1.LOCALVARIABLE) {
                    /* Rule: L1 */
                    localVariable = clone[pidx];
                    /* Rule: L2 */
                    clone.splice(pidx, 1);
                    eidx++;
                }
                else if (ePart === expressions_1.JOINER) {
                    /* Rule: J1 */
                    joiner = clone[pidx];
                    /* Rule: J2 */
                    clone.splice(pidx, 1);
                    eidx++;
                }
                else if (ePart === expressions_1.VALUE) {
                    /* Rule: V1 */
                    eidx++;
                    pidx++;
                }
                else if (ePart === expressions_1.SPACE) {
                    if (clone[pidx] !== ePart) {
                        /* Rule: S1 */
                        isMatch = false;
                        break;
                    }
                    /* Rule: S2 */
                    clone.splice(pidx, 1);
                    eidx++;
                }
                else if (Array.isArray(ePart)) {
                    _b = this.compareOrderedModifier(clone[pidx], ePart), foundIdentifier = _b[0], foundOrderedMod = _b[1];
                    if (!foundIdentifier) {
                        eidx++;
                        continue;
                    }
                    /* Rule: M5 */
                    clone.splice(pidx, 0, foundOrderedMod);
                    pidx++;
                    if (clone[pidx].length === foundIdentifier.length) {
                        /* Rule: M3 */
                        clone.splice(pidx, 1);
                    }
                    else {
                        /* Rule: M3 */
                        clone.splice(pidx, 1, clone[pidx].slice(foundIdentifier.length));
                    }
                    eidx++;
                }
                else {
                    if (clone[pidx] === expressions_1.SPACE && Array.isArray(expression.template[eidx - 1])) {
                        /* Rule: M2 */
                        clone.splice(pidx, 1);
                    }
                    /* Rule: O1 */
                    if (ePart !== clone[pidx].slice(0, ePart.length)) {
                        /* Rule: O2 */
                        isMatch = false;
                        break;
                    }
                    if (ePart.length !== clone[pidx].length) {
                        /* Rule: O3 */
                        clone.splice(pidx, 1, clone[pidx].slice(ePart.length, clone[pidx].length));
                    }
                    else {
                        /* Rule: O5 */
                        clone.splice(pidx, 1);
                    }
                    eidx++;
                }
            }
            if (isMatch) {
                /* Rule: L1 */
                if (!!localVariable)
                    dsl.local = localVariable;
                /* Rule: J1 */
                if (!!joiner)
                    dsl.joiner = joiner;
                dsl.expression = expression;
                dsl.values = clone.filter(function (x) { return typeof x === 'string'; });
                dsl.modifiers = this.sortAndExtractModifiers(clone.filter(function (x) { return typeof x === 'object'; }));
                break;
            }
        }
        if (!isMatch)
            throw error_1.SQiggLError('LE2000', "Unable to determine expression type of '" + parts.join('') + "'");
        return dsl;
        var _b;
    };
    ExpressionLexer.prototype.craftLiteralFromParts = function (parts) {
        return parts.reduce(function (a, b) { return a + b; }, '');
    };
    /**
     * Compares the "Part" of the expression with the OrderedModifiers in this index of the
     * Expression template. This method will then return both the found identifier in the "Part"
     * and the matching OrderedModifier, or will return [null, null] if not found.
     *
     * {@see Lexer.extractParts} for the definition of a "Part".
     *
     * @internal
     * @param part {string} - The "Part" of the found expression to compare.
     * @param ePart {OrderedModifier[]} - The OrderedModifier collection to compare the "Part" against.
     * @returns {{string, OrderedModifier]} - A tuple of the identifier and matching OrderedModifier found.
     */
    ExpressionLexer.prototype.compareOrderedModifier = function (part, ePart) {
        var ord, key, identifier;
        for (var _i = 0; _i < ePart.length; _i++) {
            ord = ePart[_i];
            for (var _a = 0, _b = Object.keys(ord); _a < _b.length; _a++) {
                key = _b[_a];
                for (var _c = 0, _d = ord[key].identifiers; _c < _d.length; _c++) {
                    identifier = _d[_c];
                    if (part.length >= identifier.length && identifier === part.slice(0, identifier.length)) {
                        // match
                        return [identifier, ord];
                    }
                }
            }
        }
        return [null, null];
    };
    /**
     * First sorts the modifiers based on the numbered index property, this is
     * the execution order for the modifiers defined in a Modifier template.
     * The now ordered modifiers are now extracted from the list in order
     * and returned. This is used in the parseReplacement function to create
     * the list of *found* modifiers in the expression that is currently being
     * evaluated.
     *
     * @internal
     * @param ordered: {OrderedModifier[]}
     * @returns {Modifier[]}
     */
    ExpressionLexer.prototype.sortAndExtractModifiers = function (ordered) {
        ordered = ordered.sort(function (a, b) {
            var aKey, bKey, key;
            for (key in a) {
                if (a.hasOwnProperty(key))
                    aKey = parseInt(key);
            }
            for (key in b) {
                if (b.hasOwnProperty(key))
                    bKey = parseInt(key);
            }
            return aKey < bKey ? -1 : 1;
        });
        return ordered.map(function (x) {
            var key;
            for (key in x) {
                if (x.hasOwnProperty(key))
                    return x[key];
            }
        });
    };
    return ExpressionLexer;
})();
exports.ExpressionLexer = ExpressionLexer;

},{"../error":5,"../expressions":6}],10:[function(require,module,exports){
var expression_lexer_1 = require('./expression.lexer');
/**
 * The lexer responsible for all expression tree DSL generation.
 *
 * @internal
 */
var ExpressionTreeLexer = (function () {
    /**
     * Creates a new instance of ExpressionTreeLexer
     *
     * @param options {LexerOptions} - The LexerOptions to use for DSL generation.
     * @param expressions {Expression[]} - List of known expressions to use for DSL generation.
     * @param conjunctions {Conjunction[]} - List of known conjunctions to use for DSL generation.
     */
    function ExpressionTreeLexer(options, expressions, conjunctions) {
        this.options = options;
        this.expressions = expressions;
        this.conjunctions = conjunctions;
    }
    /**
     * Determine if any of the parts match a conjunction and split the parts into
     * separate parts arrays (removing the conjunction after identifying and adding to the DSL),
     * feeding the split parts into the {@link ExpressionLexer} and then appending the results
     * onto 'branches'.
     *
     * @param parts {string[]} - The parts to generate DSL for.
     * @returns {T} - The appropriate ExpressionTree that was requested.
     */
    ExpressionTreeLexer.prototype.invoke = function (parts) {
        var dsl = {}, idx = 0, singleExpressionParts;
        while (idx < parts.length) {
            for (var _i = 0, _a = this.conjunctions; _i < _a.length; _i++) {
                var con = _a[_i];
                for (var _b = 0, _c = con.keys; _b < _c.length; _b++) {
                    var key = _c[_b];
                    if (parts[idx] === key) {
                        if (!dsl.conjunctions)
                            dsl.conjunctions = [];
                        dsl.conjunctions.push(con);
                        singleExpressionParts = parts.splice(0, idx - 1);
                        parts.splice(0, 3);
                        if (!dsl.branches)
                            dsl.branches = [];
                        dsl.branches.push(new expression_lexer_1.ExpressionLexer(this.options, this.expressions).invoke(singleExpressionParts));
                        idx = 0;
                    }
                }
            }
            idx++;
        }
        if (!dsl.branches)
            dsl.branches = [];
        dsl.branches.push(new expression_lexer_1.ExpressionLexer(this.options, this.expressions).invoke(parts));
        return dsl;
    };
    return ExpressionTreeLexer;
})();
exports.ExpressionTreeLexer = ExpressionTreeLexer;

},{"./expression.lexer":9}],11:[function(require,module,exports){
var expression_tree_lexer_1 = require("./expression.tree.lexer");
/**
 * The lexer responsible for DSL generation of all Replacement statements
 *
 * @internal
 */
var ReplacementLexer = (function () {
    /**
     * Creates a new instance of the Replacement Lexer
     *
     * @internal
     * @param options {LexerOptions} - The LexerOptions to use for all DSL generation.
     * @param expressions {Expression[]} - A list of all known expressions to use when generating DSL.
     * @param conjunctions {Conjunction[]} - A list of all known conjunctions to use when generating DSL.
     */
    function ReplacementLexer(options, expressions, conjunctions) {
        this.options = options;
        this.expressions = expressions;
        this.conjunctions = conjunctions;
    }
    /**
     * Split the input into it's respective parts then compare them against expressions
     * or return the input if the contents are literal.
     *
     * TODO: Add Rules
     *
     * @internal
     * @param input {string}
     * @param parts {string[]} - The "Parts" of the input. {@see Lexer.extractParts} for more details on the definition of a "Part".
     * @returns {DSLReplacement}
     */
    ReplacementLexer.prototype.invoke = function (input, parts) {
        var dsl = { literal: input };
        if (parts.length > 1)
            dsl.expressions = new expression_tree_lexer_1.ExpressionTreeLexer(this.options, this.expressions, this.conjunctions).invoke(parts);
        else
            dsl.literal = parts[0];
        return dsl;
    };
    /**
     * Clean and prepare the input for parsing
     *
     * @internal
     * @param input {string}
     * @returns {string}
     */
    ReplacementLexer.cleanStringForLexing = function (input) {
        return input.replace('\n', ' ').trim();
    };
    return ReplacementLexer;
})();
exports.ReplacementLexer = ReplacementLexer;

},{"./expression.tree.lexer":10}],12:[function(require,module,exports){
var lexer_1 = require('../lexer');
var dsl_1 = require('../dsl');
var error_1 = require("../error");
/**
 * The Lexer responsible for all DSL generation of variable statements
 *
 * @internal
 */
var VariableLexer = (function () {
    /**
     * Creates a new instance of the VariableLexer
     *
     * @internal
     * @param options {LexerOptions} - The LexerOptions to use when generating DSL
     */
    function VariableLexer(options) {
        this.options = options;
    }
    /**
     * Walk through a variable declaration and return a variable DSL
     *
     * TODO: Add rules
     *
     * @internal
     * @param input {string}
     * @returns {DSLVariable}
     */
    VariableLexer.prototype.invoke = function (input) {
        var currentType = dsl_1.DSLVariableType.key, original = input, idx = 0, startIdx = 0, inString = false, isArray = false, stringChar, dsl = { literal: input };
        while (idx < input.length) {
            switch (input.charAt(idx)) {
                case "'":
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2000', 'Variable keys should not be wrapped in quotes.');
                    if (!inString) {
                        inString = true;
                        stringChar = "'";
                        idx++;
                        break;
                    }
                    if (input[idx] === stringChar) {
                        if (input[idx - 1] === this.options.stringEscapeChar) {
                            input = input.slice(0, idx - 1) + input.slice(idx);
                            break;
                        }
                        else
                            inString = false;
                    }
                    idx++;
                    break;
                case '"':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2000', 'Variable keys should not be wrapped in quotes.');
                    if (!inString) {
                        inString = true;
                        stringChar = '"';
                        idx++;
                        break;
                    }
                    if (input[idx] === stringChar) {
                        if (input[idx - 1] === this.options.stringEscapeChar) {
                            input = input.slice(0, idx - 1) + input.slice(idx);
                            break;
                        }
                        else
                            inString = false;
                    }
                    idx++;
                    break;
                case '[':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2001', "Invalid character '[' found in variable key: '" + original + "'.");
                    if (!inString) {
                        if (idx !== startIdx)
                            throw error_1.SQiggLError('LV2002', "Arrays in variables cannot be nested. At '" + original + "'.");
                        input = input.slice(0, idx) + input.slice(idx + 1);
                        isArray = true;
                    }
                    break;
                case ']':
                    if (currentType === dsl_1.DSLVariableType.key)
                        throw error_1.SQiggLError('LV2001', "Invalid character ']' found in variable key: '" + original + "'.");
                    if (!inString) {
                        if (idx !== input.length - 1)
                            throw error_1.SQiggLError('LV2003', "Variables that define arrays must not include other values: '" + original + "'.");
                        input = input.slice(0, idx) + input.slice(idx + 1);
                    }
                    console.log(input);
                    idx++;
                    break;
                case this.options.variableAssignmentChar:
                    dsl = this.generateDSL(dsl, currentType, input.slice(startIdx, idx), isArray);
                    idx++;
                    startIdx = idx;
                    currentType = dsl_1.DSLVariableType.value;
                    break;
                default:
                    idx++;
            }
        }
        if (startIdx !== 0)
            dsl = this.generateDSL(dsl, currentType, input.slice(startIdx), isArray);
        return dsl;
    };
    /**
     * Generate the DSL for a variable piece by piece. Building on the definition until complete.
     *
     * @internal
     * @param dsl {DSLVariable}
     * @param type {DSLVariableType}
     * @param value {string}
     * @param isArray {boolean}
     * @returns {DSLVariable}
     */
    VariableLexer.prototype.generateDSL = function (dsl, type, value, isArray) {
        switch (type) {
            case dsl_1.DSLVariableType.key:
                dsl.key = value;
                break;
            case dsl_1.DSLVariableType.value:
                dsl.value = isArray ? this.convertCSVToArray(value) : value;
                break;
            /* istanbul ignore next */
            default:
                /* istanbul ignore next */
                throw error_1.SQiggLError('LV100', 'Unrecognized DSLVariableType');
        }
        return dsl;
    };
    VariableLexer.prototype.convertCSVToArray = function (input) {
        var items = input.split(','), result = [];
        for (var _i = 0; _i < items.length; _i++) {
            var item = items[_i];
            item = item.trim();
            result.push(lexer_1.Lexer.removeEscapeCharactersFromStringPart(item, this.options));
        }
        return result;
    };
    /**
     * Clean and prepare the input for parsing
     *
     * @internal
     * @param input {string}
     * @returns {string}
     */
    VariableLexer.cleanStringForLexing = function (input) {
        return input.replace('\n', ' ').replace(/ (?=(?:(?:\\.|"(?:\\.|[^"\\])*"|[^\\'"])*'(?:\\.|"(?:\\.|[^"'\\])*"|[^\\'])*')*(?:\\.|"(?:\\.|[^"\\])*"|[^\\'])*$)(?=(?:(?:\\.|'(?:\\.|[^'\\])*'|[^\\'"])*"(?:\\.|'(?:\\.|[^'"\\])*'|[^\\"])*")*(?:\\.|'(?:\\.|[^'\\])*'|[^\\"])*$)/g, '').trim();
    };
    return VariableLexer;
})();
exports.VariableLexer = VariableLexer;

},{"../dsl":4,"../error":5,"../lexer":7}],13:[function(require,module,exports){
/**
 * @internal
 */
exports.Not = {
    identifiers: ['!', 'not'],
    rule: function (prevResult, values) { return !prevResult; }
};
/**
 * @internal
 */
exports.OrEqual = {
    identifiers: ['='],
    rule: function (prevResult, values) { return prevResult || values[0] === values[1]; }
};
/**
 * @internal
 */
exports.LengthOrEqual = {
    identifiers: ['='],
    rule: function (prevResult, values) { return prevResult || values[0].length === +values[1]; }
};
/**
 * @internal
 */
exports.BetweenOrEqual = {
    identifiers: ['='],
    rule: function (prevResult, values) { return prevResult || +values[0] === +values[1] || +values[0] === +values[2]; }
};
exports.CORE_MODIFIERS = [
    exports.Not,
    exports.OrEqual,
    exports.LengthOrEqual,
    exports.BetweenOrEqual
];

},{}],14:[function(require,module,exports){
var comment_parser_1 = require('./parsers/comment.parser');
var replacement_parser_1 = require("./parsers/replacement.parser");
var command_parser_1 = require("./parsers/command.parser");
var error_1 = require("./error");
exports.DEFAULT_PARSER_OPTIONS = {
    exportComments: false,
    commentBeginning: '/*',
    commentEnding: '*/',
    stringEscapeChar: '\\',
    trueString: '1',
    falseString: '0'
};
/**
 * The parent parser to all specific parsers
 *
 * @internal
 */
var Parser = (function () {
    /**
     * Creates a new instance of Parser
     *
     * @internal
     * @param options {ParserOptions}
     */
    function Parser(options) {
        if (options === void 0) { options = {}; }
        /**
         * @internal
         */
        this.options = {};
        this.setOptions(options);
    }
    /**
     * Sets the options for the parser
     *
     * @internal
     * @param options {ParserOptions}
     */
    Parser.prototype.setOptions = function (options) {
        for (var _i = 0, _a = Object.keys(exports.DEFAULT_PARSER_OPTIONS); _i < _a.length; _i++) {
            var key = _a[_i];
            this.options[key] = options[key] || exports.DEFAULT_PARSER_OPTIONS[key];
        }
        return this;
    };
    /**
     * Walk the DSL and generate final SQL output
     *
     * @internal
     * @param dsl {DSL[]} - The DSL generated by the Lexer
     * @param variables {ScopedVariables}
     * @returns {string} - The final SQL output
     */
    Parser.prototype.parse = function (dsl, variables) {
        if (variables === void 0) { variables = {}; }
        var output = '', idx;
        for (idx = 0; idx < dsl.length; idx++) {
            if (dsl[idx].variable)
                variables = this.resolveVariable(dsl[idx].variable, variables);
            if (dsl[idx].command && !!dsl[idx].command.action.rule) {
                if ((!!dsl[idx].command.action.dependents && dsl[idx - 1].command.failed !== true))
                    continue;
                output += new command_parser_1.CommandParser(this.options).parse(dsl[idx].command, dsl[idx].scope, variables);
            }
            if (dsl[idx].replacement) {
                output += new replacement_parser_1.ReplacementParser(this.options).parse(dsl[idx].replacement, variables);
            }
            if (dsl[idx].comment && this.options.exportComments) {
                output += new comment_parser_1.CommentParser(this.options).parse(dsl[idx].comment);
            }
            if (dsl[idx].text)
                output += dsl[idx].text;
        }
        return output;
    };
    /**
     * Resolve the known variables within the scope and return the modified collection
     *
     * @param dsl {DSLVariable}
     * @param scopedVariables {ScopedVariables}
     * @returns {ScopedVariables}
     */
    Parser.prototype.resolveVariable = function (dsl, scopedVariables) {
        scopedVariables[dsl.key] = Parser.resolveValue(dsl.value, scopedVariables);
        return scopedVariables;
    };
    /**
     * Resolves a value as either a literal string, literal number,
     * or a variable value and then returns that value as a string.
     *
     * - If the value is an array, return it unchanged
     * - If the value starts with a quote, then it must be a string literal.
     *   Strip the quotes and return the literal value.
     * - If the value is a number, then it must be a literal number.
     *   Return the number unchanged.
     * - If a variable has the same name as the value, then resolve the
     *   value to the variable and return the value of the variable.
     * - Throw an error if none of the above.
     *
     * @internal
     * @param value {string | number | string[]} - The value to resolve.
     * @param variables {ScopedVariables} - The list of known variables for this scope.
     * @param suppressUndefinedVariableError {boolean} - Do not throw an error if a value cannot be resolved.
     * @returns {string} - The resolved value.
     */
    Parser.resolveValue = function (value, variables, suppressUndefinedVariableError) {
        if (suppressUndefinedVariableError === void 0) { suppressUndefinedVariableError = false; }
        if (Array.isArray(value))
            return value;
        if (value[0] === "'" || value[0] === "\"")
            return value.slice(1, value.length - 1);
        if (!isNaN(+value))
            return value.toString();
        if (!!variables && variables.hasOwnProperty(value))
            return variables[value];
        if (!suppressUndefinedVariableError)
            throw error_1.SQiggLError('P1000', value + " is not a defined variable in this scope");
    };
    return Parser;
})();
exports.Parser = Parser;

},{"./error":5,"./parsers/command.parser":15,"./parsers/comment.parser":16,"./parsers/replacement.parser":19}],15:[function(require,module,exports){
var parser_1 = require('../parser');
var expression_tree_parser_1 = require('./expression.tree.parser');
/**
 * The parser responsible for parsing all DSLCommands
 *
 * @internal
 */
var CommandParser = (function () {
    /**
     * Creates a new instance of CommandParser.
     *
     * @internal
     * @param options {ParserOptions} - The {@link ParserOptions} for string output.
     */
    function CommandParser(options) {
        this.options = options;
    }
    /**
     * Take a DSLReplacement, run any expressions against it, and output the final string.
     *
     * @internal
     * @param dsl {DSLCommand} - The DSL to parse.
     * @param scope {DSL[]} - The scope that is below this command.
     * @param variables {ScopedVariables} - The list of all known variables for this scope.
     * @returns {string} - The final output string for this command.
     */
    CommandParser.prototype.parse = function (dsl, scope, variables) {
        var action = dsl.action;
        var expressionResult, result;
        if (!!action.rule) {
            if (!!dsl.expressions) {
                expressionResult = new expression_tree_parser_1.ExpressionTreeParser(this.options).parse(dsl.expressions, variables);
                if (!!expressionResult.iterable)
                    result = action.rule(expressionResult, variables, scope, new parser_1.Parser(this.options));
                else
                    result = action.rule(expressionResult, variables, scope, new parser_1.Parser(this.options));
            }
            else {
                result = action.rule({ value: dsl.literalValue }, variables, scope, new parser_1.Parser(this.options));
            }
        }
        if (result === null)
            dsl.failed = true;
        return result || '';
    };
    return CommandParser;
})();
exports.CommandParser = CommandParser;

},{"../parser":14,"./expression.tree.parser":18}],16:[function(require,module,exports){
/**
 * The parser responsible for parsing all DSL Comments
 *
 * @internal
 */
var CommentParser = (function () {
    /**
     * Creates a new instance of CommentParser
     *
     * @param options {ParserOptions} - The {@link ParserOptions} for string output.
     */
    function CommentParser(options) {
        this.options = options;
    }
    /**
     * Change the comment into a SQL comment using the provided start and ending tokens
     * and output the newly formatted comment
     *
     * @internal
     * @param comment {string} - The DSL for a comment is simply a string
     * @returns {string}
     */
    CommentParser.prototype.parse = function (comment) {
        return this.options.commentBeginning + " " + comment + " " + this.options.commentEnding;
    };
    return CommentParser;
})();
exports.CommentParser = CommentParser;

},{}],17:[function(require,module,exports){
var parser_1 = require('../parser');
/**
 * The parser responsible for parsing all DSLExpressions.
 *
 * @internal
 */
var ExpressionParser = (function () {
    /**
     * Creates a new instance of ExpressionParser.
     *
     * @internal
     * @param options {ParserOptions} - The {@link ParserOptions} for string output.
     */
    function ExpressionParser(options) {
        this.options = options;
    }
    /**
     * Take a DSLExpression and output the final string or boolean.
     *
     * @internal
     * @param dsl {DSLExpression} - The DSL to parse.
     * @param variables {ScopedVariables} - The list of known variables for this scope.
     * @returns {ExpressionResult} - The result of the expression.
     */
    ExpressionParser.prototype.parse = function (dsl, variables) {
        var idx, result = { value: null };
        for (idx = 0; idx < dsl.values.length; idx++) {
            dsl.values[idx] = parser_1.Parser.resolveValue(dsl.values[idx], variables, !!dsl.expression.suppressUndefinedVariableError);
        }
        result.value = dsl.expression.rule(dsl.values, dsl.literal);
        if (!!dsl.modifiers) {
            for (var _i = 0, _a = dsl.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                // Should remove this <any> cast once possible. This is an ugly hack and should be corrected.
                result.value = modifier.rule(result.value, dsl.values);
            }
        }
        if (!!dsl.joiner && dsl.local) {
            result.iterable = {
                joiner: dsl.joiner,
                local: dsl.local
            };
        }
        return result;
    };
    return ExpressionParser;
})();
exports.ExpressionParser = ExpressionParser;

},{"../parser":14}],18:[function(require,module,exports){
var expression_parser_1 = require('./expression.parser');
/**
 * The parser responsible for parsing all DSLExpressionTrees
 *
 * @internal
 */
var ExpressionTreeParser = (function () {
    /**
     * Creates a new instance of ExpressionTreeParser
     *
     * @param options {ParserOptions} - The {@link ParserOptions} used for string output.
     */
    function ExpressionTreeParser(options) {
        this.options = options;
    }
    /**
     * Take a DSLExpressionTree and parse each of the expressions contained in it, joining the
     * results with the conjunctions used and outputting an ExpressionResult to be used by a
     * {@link Replacement} or a {@link Command}
     *
     * @param dsl {DSLExpressionTree} - The DSLExpressionTree to parse.
     * @param variables {ScopedVariables} - The ScopedVariables to use for parsing.
     * @returns {ExpressionResult} - The final result of evaluating the expression tree.
     */
    ExpressionTreeParser.prototype.parse = function (dsl, variables) {
        var result, idx = 0;
        while (idx < dsl.branches.length) {
            var current = new expression_parser_1.ExpressionParser(this.options).parse(dsl.branches[idx], variables);
            if (idx > 0 && dsl.conjunctions[idx - 1]) {
                result.value = dsl.conjunctions[idx - 1].rule([result.value, current.value]);
            }
            else
                result = current;
            idx++;
        }
        return result;
    };
    return ExpressionTreeParser;
})();
exports.ExpressionTreeParser = ExpressionTreeParser;

},{"./expression.parser":17}],19:[function(require,module,exports){
var parser_1 = require('../parser');
var expression_tree_parser_1 = require('./expression.tree.parser');
/**
 * The parser responsible for all DSLReplacements.
 *
 * @internal
 */
var ReplacementParser = (function () {
    /**
     * Creates a new instance of ReplacementParser
     *
     * @internal
     * @param options {ParserOptions} - The {@link ParserOptions} for string output.
     */
    function ReplacementParser(options) {
        this.options = options;
    }
    /**
     * Take a DSLReplacement, run any expressions against it, and output the final string.
     *
     * @internal
     * @param dsl {DSLReplacement} - The DSL to parse.
     * @param variables {ScopedVariables} - The list of known variables for this scope.
     * @returns {string} - The final output string for this replacement.
     */
    ReplacementParser.prototype.parse = function (dsl, variables) {
        var output, result;
        if (!!dsl.expressions) {
            result = new expression_tree_parser_1.ExpressionTreeParser(this.options).parse(dsl.expressions, variables);
            if (!!result.iterable) {
                output = result.value.join(parser_1.Parser.resolveValue(result.iterable.joiner, variables) + " ");
            }
            else {
                output = result.value;
            }
        }
        else {
            output = parser_1.Parser.resolveValue(dsl.literal, variables).toString();
        }
        if (output === true)
            return this.options.trueString;
        if (output === false)
            return this.options.falseString;
        return output;
    };
    return ReplacementParser;
})();
exports.ReplacementParser = ReplacementParser;

},{"../parser":14,"./expression.tree.parser":18}],20:[function(require,module,exports){
var lexer_1 = require('./lexer');
var parser_1 = require('./parser');
/**
 * Parses a SQiggL query and outputs the raw SQL.
 *
 * @param query {string} - The SQiggL query to parse.
 * @param variables {ScopedVariables} - A map of variables to use while parsing.
 * @param options {SQiggLOptions} - The options to use for parsing
 * @returns {string} - The raw SQL query output.
 */
function parse(query, variables, options) {
    var lexer = new lexer_1.Lexer(options);
    var dsl = lexer.parse(query);
    var parser = new parser_1.Parser(options);
    return parser.parse(dsl, variables);
}
/**
 * The SQiggL library export.
 *
 * @type {{parse: (function(string, ScopedVariables=, SQiggLOptions=): string)}}
 */
exports.SQiggL = { parse: parse };

},{"./lexer":7,"./parser":14}]},{},[1]);
